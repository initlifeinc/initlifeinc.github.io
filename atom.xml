<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[initlife's Blog]]></title>
  <link href="http://initlifeinc.github.io/atom.xml" rel="self"/>
  <link href="http://initlifeinc.github.io/"/>
  <updated>2015-10-28T17:15:59+08:00</updated>
  <id>http://initlifeinc.github.io/</id>
  <author>
    <name><![CDATA[initlife]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS里的栈限制引发的crash]]></title>
    <link href="http://initlifeinc.github.io/blog/2015/10/28/iosli-de-zhan-xian-zhi-yin-fa-de-crash/"/>
    <updated>2015-10-28T17:14:53+08:00</updated>
    <id>http://initlifeinc.github.io/blog/2015/10/28/iosli-de-zhan-xian-zhi-yin-fa-de-crash</id>
    <content type="html"><![CDATA[<p>昨天一个开发说，app一启动就崩溃，而且是添加了一个比较变态的测试数据后引发的，调试后发现崩溃在IDL的解析代码里，结果分析测试发现原来问题出现在iOS栈上。</p>

<h1>问题分析</h1>

<p>代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(NSData *) readRaw: (uint8_t) t
</span><span class='line'>{
</span><span class='line'>    int32_t len = 0;
</span><span class='line'>    if ((t & 0xe0) == 0xa0) { // FixArray
</span><span class='line'>        len = t & 0x1f;
</span><span class='line'>    } else if ((t & 0xff) == 0xda) { // raw 16
</span><span class='line'>        len = (uint16_t)[inputStream readShort];
</span><span class='line'>    } else if ((t & 0xff) == 0xdb) {// raw 32
</span><span class='line'>        len = (uint32_t)[inputStream readInt];
</span><span class='line'>    }
</span><span class='line'>    if (len == 0) {
</span><span class='line'>        return nil;
</span><span class='line'>    }
</span><span class='line'>    uint8_t buffer[len];
</span><span class='line'>    [inputStream readBytes:buffer length:len];
</span><span class='line'>    return [NSData dataWithBytes:(const char *)&buffer length: len];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>// read
</span><span class='line'>-(unsigned int) readBytes: (uint8_t *)buff length: (unsigned int) len
</span><span class='line'>{
</span><span class='line'>    if(len &lt;= 0){
</span><span class='line'>        @throw [NSException exceptionWithName:@"PackException" reason:@"args is illegal" userInfo:nil ];
</span><span class='line'>    }
</span><span class='line'>    if (totalSize - mOffset &lt; len) {
</span><span class='line'>        @throw [NSException exceptionWithName:@"EOFException" reason:@"Not enough bytes remain in buffer" userInfo:nil ];
</span><span class='line'>  }
</span><span class='line'>  [mBuffer getBytes:buff range:NSMakeRange(mOffset, len)];//&lt;===崩溃在这里。
</span><span class='line'>  mOffset += len;
</span><span class='line'>    if (mOffset &gt;= GARBAGE_BUFFER_SIZE) {
</span><span class='line'>      [mBuffer replaceBytesInRange:NSMakeRange(0, mOffset) withBytes:NULL length:0];
</span><span class='line'>      mOffset = 0;
</span><span class='line'>        totalSize = [mBuffer length];
</span><span class='line'>  }
</span><span class='line'>  return len;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>error错误是bad access，而<code>从-(unsigned int) readBytes: (uint8_t *)buff length: (unsigned int) len</code>函数本来来看基本很难看出来，所以需要往上看一个函数调用，从代码本身来看也还算正常，当然细心的人可能会看到这里有个比较危险的代码，没错就是它。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (len == 0) {
</span><span class='line'>    return nil;
</span><span class='line'>}
</span><span class='line'>uint8_t buffer[len];      //&lt;====就是它
</span><span class='line'>[inputStream readBytes:buffer length:len];</span></code></pre></td></tr></table></div></figure>


<p>len的大小其实是不可控的，是由服务端返回的一个值，用来表示msgpack后面的某个字段的数据的长度。而这里使用了栈申请内存，此时就面临万一len大于一定值后，导致申请内存会破坏栈了。</p>

<p>当然在我们申请内存的时候并不会崩溃，毕竟这里还没有开始写操作，而当你调用<code>[mBuffer getBytes:buff range:NSMakeRange(mOffset, len)];</code>方法的时候，就棉铃将数据mBuffer里的数据copy到buff对象里了，此时就会将栈上的数据给破坏掉了，从而导致崩溃。因此也就解释了为什么崩溃是在后面的方法里。</p>

<h2>处理结果</h2>

<p>既然知道了是栈申请大内存导致栈被破坏掉了而引发的崩溃，所以自然需要将栈内存改成堆内存就可以了。在不大规模修改代码的情况下，便有了下面的fix代码</p>

<pre><code> uint8_t *buffer = malloc(len+1);
memset(buffer, 0, sizeof(buffer));
[inputStream readBytes:buffer length:len];
return [NSData dataWithBytesNoCopy:(void *)buffer length:len];
</code></pre>

<p>为了尽量少的内存拷贝，首选dataWithBytesNoCopy。</p>

<h2>结论</h2>

<p>那么到底这个栈有多大呢？平时碰到的，google了下，结论是：</p>

<p><strong>iOS上主线程栈大小1MB，其他线程512K，OSX上主线程栈大小8M</strong></p>

<p><img src="https://static.dingtalk.com/media/lALOAjbqsM0Bac0Eng_1182_361.png_450x10000q90.jpg" alt="stack size limit" /></p>

<p>更多详细请看：</p>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html</a></p>

<p>另外说明下，对于不可知大小的内存申请，本来也不应该通过栈申请内存来做数据处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过NSURLProtocol拦截HTTP转HTTPS来整合SPDY的记录]]></title>
    <link href="http://initlifeinc.github.io/blog/2015/10/19/tong-guo-nsurlprotocollan-jie-httpzhuan-httpslai-zheng-he-spdyde-ji-lu/"/>
    <updated>2015-10-19T19:53:35+08:00</updated>
    <id>http://initlifeinc.github.io/blog/2015/10/19/tong-guo-nsurlprotocollan-jie-httpzhuan-httpslai-zheng-he-spdyde-ji-lu</id>
    <content type="html"><![CDATA[<h1>通过NSURLProtocol拦截HTTP转HTTPS来整合SPDY的记录</h1>

<p>众所周知，iOS 9.0之后苹果引入ATS限制，苹果也推荐尽量不要使用HTTP通讯了，毕竟是很不安全的。而国内各个有(wu)节操的运营商也会经常篡改请求HTTP请求。所以如果可能，在不影响性能的情况下，使用https总是更好一点。但是移动网络下HTTPS的握手耗时，也总是很让人难已接受。那么考虑整合Spdy来减少握手时间的损耗，复用链接来进行通讯，是一个不错的尝试。</p>

<p>但对于老的app，尤其是本地已经存储了大量的老旧URL来说，尝试数据升级将本地数据库里的各种http转成https的操作也是令人发指的，尤其是这种操作很不适合做灰度测试发布。总不能数据改来改去，对于那些可能本地存了几万几十万条消息记录的app来说，简直是灾难。因此如何寻求在老的app上完成http的请求转https的请求，以及整合spdy来减少握手时间，提升弱网效果就显的很重要，而我们应该寻找优雅的解决方式来完成过渡。</p>

<p>注：这里不讨论为什么不用HTTP2.0，不选择总有不选择的原因，再换个角度，你完成了spdy的接入，HTTP2.0的接入从大体思路上是类似的。</p>

<p>注：由于NSURLProtocol的拦截及再发送，涉及的坑很多，这里先不讲了，大家也可以参考下<a href="https://github.com/marcuswestin/WebViewProxy">这个</a>，里面已经埋了不少坑。</p>

<h2>Spdy的选择及注意事项</h2>

<p>对于iOS来说，现有的spdy开源库，暂时可以考虑<a href="https://github.com/twitter/CocoaSPDY">CocoaSpdy</a>, 说起Spdy，大家第一反应一般是多路复用请求（multiplexing requests），头部压缩等特性，其实Spdy的设计里充分考虑了cancel的需要，这个特性其实也是非常重要的，否则复用链接会引入一个灾难的问题（就是上层已经cancel的请求在复用链路中堆积而影响后续各种请求）。</p>

<p>注：以下我们考虑的是采用NSURLConnection的请求的拦截。</p>

<p>CocoaSpdy的设计里采用在SPDYURLConnectionProtocol的load函数里将自己注册到NSURLProtocol里，作为独立的第三方库，这个可以帮你省却一些烦恼，快速接入Spdy。</p>

<p>但是当你发现你的app可能因为已经引入另一个NSURLProtocol的子类来做流量统计，缓存命中，甚至HTTPDNS的转换（不了解这块的可以查看下<a href="http://mp.weixin.qq.com/s?__biz=MzA3ODgyNzcwMw==&amp;mid=201837080&amp;idx=1&amp;sn=b2a152b84df1c7dbd294ea66037cf262&amp;scene=2&amp;from=timeline&amp;isappinstalled=0#rd">这里</a>）的时候，那么默认的load自动注册可能会引发拦截顺序问题，所以这里我还是注释掉了cocoaspdy的这个代码。改由自己手动注册，注意如果你要关注下注册的顺序和生效的顺序，先注册的后生效。</p>

<h3>接入基本步骤：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1. 注册SPDYURLConnectionProtocol
</span><span class='line'>2. 注册original，即针对哪个scheme，host，port进行拦截
</span><span class='line'>3. 设置logger的delegate和logLevel，另外可以考虑设置并发数。
</span><span class='line'>4. 等待相关的URL请求触发相关protocol的拦截，CocoaSpdy内部会解析请求，并进行相关请求及返回。</span></code></pre></td></tr></table></div></figure>


<p>也可以看下如下的基本代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 先注册spdy的protocol
</span><span class='line'>[NSURLProtocol registerClass:[SPDYURLConnectionProtocol class]];
</span><span class='line'>// 下面这个可以先忽略，用于拦截http转https等用处
</span><span class='line'>[NSURLProtocol registerClass:NSClassFromString(@"ILURLProtocol")];
</span><span class='line'>
</span><span class='line'>// 注册拦截的规则，这里是预注册，如果你使用过程中有新引入一些域名，也可以临时再添加注册
</span><span class='line'>[SPDYURLConnectionProtocol registerOrigin:@"https://static.dingtalk.com"];
</span><span class='line'>// log的delegate和loglevel
</span><span class='line'>[SPDYProtocol setLogger:self];
</span><span class='line'>[SPDYProtocol setLoggerLevel:SPDYLogLevelDebug];
</span><span class='line'>// 设置pool的并发数，注意，这个是针对每个origin的的size。
</span><span class='line'>SPDYConfiguration *configration = [SPDYProtocol currentConfiguration];
</span><span class='line'>configration.sessionPoolSize = 3;
</span><span class='line'>[SPDYProtocol setConfiguration:configration];
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>完成后，就可以通过下载https图片来观察下载情况了（注意spdy的日志打印）
</span><span class='line'>比如引入sdwebimage显示图片，
</span><span class='line'>
</span><span class='line'>NSString imageurl = @"https://static.dingtalk.com/media/lADOAaoJdM0FNs0D6A_1000_1334.jpg_790x10000g.jpg";
</span><span class='line'>[cell.imageView sd_setImageWithURL:[NSURL URLWithString:imageurl]
</span><span class='line'>                  placeholderImage:[UIImage imageNamed:@"lock"]
</span><span class='line'>                           options:SDWebImageRefreshCached|SDWebImageCacheMemoryOnly
</span><span class='line'>                         completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) {
</span><span class='line'>                                 NSLog(@"%@ %@ %ld", image, error, (long)cacheType);
</span><span class='line'>                             }];</span></code></pre></td></tr></table></div></figure>


<h3>Spdy的一些基本概念和关系</h3>

<p>Spdy在SSL层上加了一个SPDY session 层，来实现并发和stream机制。对CocoaSpdy来说，也就有SPDYSessionManager的概念，每个origin（SPDYStream）都有一个session manager（SPDYSessionManager），管理session pool和stream队列，每个session（SPDYSession，相当于一条spdy链接）都可以用来发送stream，每个stream就意味着上层发起的一个request，cancel一个请求，实际上是cancel一个stream，cancel也不是简单的移除stream，更会向服务端发起cancel stream的操作。服务端收到后会停止继续推送当前正在处理的stream请求的数据。这对于大数据量的文件下载尤为重要。</p>

<h2>HTTP进行HTTPDNS和HTTPS的URL拦截转换</h2>

<p>我们需要拦截HTTP，也要拦截那些指定域名被HTTPDNS之后的请求，比如
@&ldquo;<a href="http://static.dingtalk.com/media/lADOAAJMIs0CgM0CgA_640_640.jpg_90x90.jpg">http://static.dingtalk.com/media/lADOAAJMIs0CgM0CgA_640_640.jpg_90x90.jpg</a>&rdquo; 经过httpdns处理之后，获取到的ip可能为 @&ldquo;<a href="http://110.75.113.81/media/lADOAAj5i80CgM0CgA_640_640.jpg_90x90.jpg">http://110.75.113.81/media/lADOAAj5i80CgM0CgA_640_640.jpg_90x90.jpg</a>&#8220;，host填为static.dingtalk.com。
此时我们同样可以将这个<a href="http://110.75.113.81/media/lADOAAj5i80CgM0CgA_640_640.jpg_90x90.jpg">http://110.75.113.81/media/lADOAAj5i80CgM0CgA_640_640.jpg_90x90.jpg</a> 拦截下来（通过在request header里的host判断，当然对于spdy来说，你还需要注册对于110.75.113.81的拦截，而且最好还要添加对于host里的域名判断）。</p>

<p>这里还涉及到如何让spdy支持对IP类型的地址进行https握手建连的问题，这里需要说明的是，服务端配spdy的时候需要支持SNI的扩展，客户端在ssl建连的时候也需要主动握手参数添加kCFStreamSSLPeerName值为host来覆盖用于证书校验的名字。</p>

<p>我修改了下CocoaSpdy里的_tryTLSHandhshake的部分代码，从而让ip类型的服务器地址支持https握手建连。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 注：SpdyOrigin类被改造支持domainHost参数来保存host值，这样原host就可以保存ip，这里保存时机host了。
</span><span class='line'>if (_endpoint.origin.domainHost.length &gt; 0) {
</span><span class='line'>            NSMutableDictionary *newTlsSettings = [tlsOp-&gt;_tlsSettings mutableCopy];
</span><span class='line'>            newTlsSettings[(__bridge NSString *)kCFStreamSSLPeerName] = _endpoint.origin.domainHost;
</span><span class='line'>            tlsOp-&gt;_tlsSettings = newTlsSettings;
</span><span class='line'>        }</span></code></pre></td></tr></table></div></figure>


<p>spdy里http转https的一些主要代码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (BOOL)canInitWithRequest:(NSURLRequest *)request
</span><span class='line'>{
</span><span class='line'>    // 由于我们做的是将http转成https，所以就不怕行程循环触发protocol
</span><span class='line'>    if ([request.URL.scheme isEqualToString:@"http"]) {
</span><span class='line'>        return YES;
</span><span class='line'>    }
</span><span class='line'>    return NO;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request
</span><span class='line'>{
</span><span class='line'>    return [self tryGetHttpsRequest:request];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (NSURLRequest *)tryGetHttpsRequest:(NSURLRequest *)oldReq
</span><span class='line'>{
</span><span class='line'>    NSString *oldScheme = [[oldReq.URL scheme] lowercaseString];
</span><span class='line'>    
</span><span class='line'>    if ([oldScheme isEqualToString:@"http"] && [self shouldInterceptorRequest:oldReq]) {
</span><span class='line'>        NSMutableURLRequest *newReq = [oldReq mutableCopy];
</span><span class='line'>        NSURL *newUrl = [[NSURL alloc] initWithScheme:@"https" host:oldReq.URL.host path:oldReq.URL.path];
</span><span class='line'>        newReq.URL = newUrl;
</span><span class='line'>        // 下面这段代码是因为现有的有spdy服务器对于strem header里中文直接断开连接，而cocoaspdy里获取的是应用的名称，如果你的名称正好是中文，会导致steam一发送就被rst，所以我们主动去创建一个host，这样spdy就不会用内部的defaultuseragent来覆盖
</span><span class='line'>        if (![newReq valueForHTTPHeaderField:@"User-Agent"]) {
</span><span class='line'>            NSMutableDictionary *allHTTPHeaderFields = [newReq.allHTTPHeaderFields mutableCopy];
</span><span class='line'>            [allHTTPHeaderFields setObject:[self getDefaultUserAgent] forKey:@"User-Agent"];
</span><span class='line'>            newReq.allHTTPHeaderFields = allHTTPHeaderFields;
</span><span class='line'>        }
</span><span class='line'>        return newReq;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return oldReq;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (instancetype)initWithHosts:(NSArray *)hosts
</span><span class='line'>{
</span><span class='line'>    self = [super init];
</span><span class='line'>    if (self)
</span><span class='line'>    {
</span><span class='line'>      //拦截HTTP,并且host为指定的host
</span><span class='line'>        _predicate = [NSPredicate predicateWithFormat:@"scheme MATCHES 'http' AND host IN[cd] %@", hosts];
</span><span class='line'>        _hostPredicate = [NSPredicate predicateWithFormat:@"SELF IN[cd] %@", hosts];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (BOOL)shouldInterceptorRequest:(NSURLRequest *)request
</span><span class='line'>{
</span><span class='line'>    if ([self.predicate evaluateWithObject:request.URL])
</span><span class='line'>    {
</span><span class='line'>        return YES;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    // 这个是针对httpdns之后，host已经转到request里的host字段里了，所以做二次判断。
</span><span class='line'>    if ([self isHeaderHostVaild:request]) {
</span><span class='line'>        return YES;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return NO;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (BOOL)isHeaderHostVaild:(NSURLRequest *)request
</span><span class='line'>{
</span><span class='line'>    NSString *hostInHeader = [request valueForHTTPHeaderField:@"Host"];
</span><span class='line'>    if (hostInHeader && [self.hostPredicate evaluateWithObject:hostInHeader]) {
</span><span class='line'>        return YES;
</span><span class='line'>    }
</span><span class='line'>    return NO;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>One more thing</h2>

<p>当你完成http转httpdns，转https之后，你可能碰到sdwebimage在滚出页面的时候，会去cancel request，但是走spdy之后，它会触发protocol的stopLoading方法，此时需要关注这个stopLoading触发的时候，此前用于2次转发的NSUrlConnection对象我们需要判断handler是否可用，如果可用，说明并不是正常结束，而是被cancel了，此时应该执行[connectoin cancel]操作。</p>

<h2>关于ATS</h2>

<p>这里简单说明下ATS，不细说，详情各位看官自己google下，一大堆资料,也可以查看<a href="http://initlife.com/blog/2015/09/23/ios9gua-pei/">这里</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9适配]]></title>
    <link href="http://initlifeinc.github.io/blog/2015/09/23/ios9gua-pei/"/>
    <updated>2015-09-23T10:53:46+08:00</updated>
    <id>http://initlifeinc.github.io/blog/2015/09/23/ios9gua-pei</id>
    <content type="html"><![CDATA[<h1>iOS9适配</h1>

<p>提交iOS app的时候，踩了一遍开发都需要踩的坑，虽然其他地方都能找到，这里还是说下自己的坑</p>

<h2>一、App Transport Security</h2>

<p>xcode7安装后，你会发现ios9之后后默认所有http请求都无法继续有效，但是基于现状，我们并不能这么快改成https请求，所以基本上大多数app都会选择兼容老模式</p>

<p>如果服务不改变，则客户端info.plist的根<dict>需加下面的键值（这些key可以手动在project的info里直接添加和修改）</p>

<p>简单信任所有http服务器</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;
</span><span class='line'>&lt;dict&gt;
</span><span class='line'>      &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; 
</span><span class='line'>  &lt;true/&gt;
</span><span class='line'>&lt;/dict&gt; </span></code></pre></td></tr></table></div></figure>


<p>或者另外严谨一些</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;
</span><span class='line'>&lt;dict&gt;  
</span><span class='line'>  &lt;key&gt;NSExceptionDomains&lt;/key&gt;  
</span><span class='line'>      &lt;dict&gt;    
</span><span class='line'>          &lt;key&gt;yourserver.com&lt;/key&gt;    
</span><span class='line'>              &lt;dict&gt;      
</span><span class='line'>              &lt;!--Include to allow subdomains--&gt;      
</span><span class='line'>              &lt;key&gt;NSIncludesSubdomains&lt;/key&gt;
</span><span class='line'>                  &lt;true/&gt;
</span><span class='line'>              &lt;!--Include to allow insecure HTTP requests--&gt;                    &lt;key&gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&lt;/key&gt;     
</span><span class='line'>                  &lt;true/&gt;
</span><span class='line'>              &lt;!--Include to specify minimum TLS version--&gt;      
</span><span class='line'>              &lt;key&gt;NSTemporaryExceptionMinimumTLSVersion&lt;/key&gt;      
</span><span class='line'>                  &lt;string&gt;TLSv1.2&lt;/string&gt;    
</span><span class='line'>              &lt;!--whether domain support forward secrecy using ciphers, if not support, set false--&gt;
</span><span class='line'>              &lt;key&gt;NSExceptionRequiresForwardSecrecy&lt;/key&gt;
</span><span class='line'>                  &lt;false/&gt;
</span><span class='line'>              &lt;/dict&gt;  
</span><span class='line'>      &lt;/dict&gt;
</span><span class='line'>&lt;/dict&gt; </span></code></pre></td></tr></table></div></figure>


<p>另外由于苹果的https的限制(注意理论上苹果ATS生效的是调用NSURLConnection, CFURL, or NSURLSession APIs的所有连接)，还不仅仅限于任何https，还必须满足一定的其他要求，比如加密算法的要求，TLS的协议版本等。(详情查看<a href="https://developer.apple.com/library/prerelease/ios/technotes/App-Transport-Security-Technote/">https://developer.apple.com/library/prerelease/ios/technotes/App-Transport-Security-Technote/</a>)</p>

<p>比如网上有人分析了百度的https就不能满足默认的苹果https安全传输要求，因为它的TLS虽然满足TLS1.2,但是加密算法是：SHA-1 with RSA Encryption ，所以依然会被报警，所以，这种exception的情况也需要额外标注，上面的官方连接也有说明,即添加NSExceptionRequiresForwardSecrecy，并设置为false，禁止forword secrecy。</p>

<h2>二、bitcode</h2>

<p>xcode7 默认开启，bitcode（iwatch需要），则会导致部分第三方框架报错（比如友盟的错误）</p>

<p>libMobClickLibrary.a(MobClick.o)&lsquo; does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture armv7</p>

<p>这是要么更新库，要么可以在 build setting 中，搜索bitcode,并把enable bitcode 设置为 NO，这个因各自app情况而定，实际上本身不会降低上传包大小，只是开启后能降低用户下载的大小。苹果会自动根据用户自身的设备选择相关架构的下载</p>

<h2>三、iOS9安装企业证书打包的app</h2>

<p>企业证书打包的app，安装到手机里面后第一次打开app。不会像以前一样自动提示，信任还是不信任该证书；</p>

<p>这是个时候需要iOS9 设置-》通用-》描述文件-》企业级应用 中信任对应的企业开发者。</p>

<h2>四、iOS9 URL Schemes</h2>

<p>苹果新上线urlScheme的限制</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>If you call the “canOpenURL” method on a URL that is not in your whitelist, 
</span><span class='line'>  it will return “NO”, even if there is an app installed that has registered to handle this scheme. A “This app is not allowed to query for scheme xxx” syslog entry will appear.
</span><span class='line'>
</span><span class='line'>If you call the “openURL” method on a URL that is not in your whitelist, 
</span><span class='line'>  it will fail silently. A “This app is not allowed to query for scheme xxx” syslog entry will appear.</span></code></pre></td></tr></table></div></figure>


<p>更多信息:WWDC 2015 Session 703: &ldquo;Privacy and Your App&rdquo;  <a href="https://developer.apple.com/videos/wwdc/2015/?id=703">https://developer.apple.com/videos/wwdc/2015/?id=703</a></p>

<p>因此现在要搞分享的时候，除了要在项目info URL Types中设置URL Schemes，还需要在info.plist里面增加可信任的调用app url scheme，否则回报如下错误</p>

<p>-canOpenURL: failed for URL: &ldquo;weixin://app/wx********/&rdquo; - error: &ldquo;This app is not allowed to query for scheme weixin&rdquo;</p>

<p>只需要添加如下代码即可，在info.plist里加入</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;
</span><span class='line'>  &lt;array&gt;
</span><span class='line'>  &lt;string&gt;weixin&lt;/string&gt;
</span><span class='line'>  &lt;string&gt;wechat&lt;/string&gt;
</span><span class='line'>  &lt;string&gt;sina&lt;/string&gt;
</span><span class='line'>  &lt;string&gt;weibo&lt;/string&gt;
</span><span class='line'>&lt;/array&gt;</span></code></pre></td></tr></table></div></figure>


<p>你也可以查看友盟分享SDK适配iOS9的文档：<a href="http://dev.umeng.com/social/ios/ios9">http://dev.umeng.com/social/ios/ios9</a></p>

<p>未完待续</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个pod Update遇到的错误处理]]></title>
    <link href="http://initlifeinc.github.io/blog/2015/09/02/%5B%3F%5D-ge-pod-updateyu-dao-de-cuo-wu-chu-li/"/>
    <updated>2015-09-02T19:52:17+08:00</updated>
    <id>http://initlifeinc.github.io/blog/2015/09/02/[?]-ge-pod-updateyu-dao-de-cuo-wu-chu-li</id>
    <content type="html"><![CDATA[<p>pod update的时候生成xcworkspace后，link的时候碰到了一个问题，就是一些pod里的库link不到，当然此时你可以跑到工程里主动添加link lib也是可以解决问题，不过那是治标不治本，实际上的处理应该是：</p>

<ol>
<li><p>观察pod update的时候的提示，比如我这个是有如下提示：</p>

<pre><code class="`"> target overrides the `OTHER_LDFLAGS` build setting defined in `Pods/Target Support Files/Pods/Pods.debug.xcconfig'. This can lead to problems with the CocoaPods installation
</code></pre>

<p> 此时很明显说明pod生成的xcconfig文件里关于OTHER_LDFLAGS的设置和工程里的build setting冲突了，最后target的设置覆写了xcconfig里的设置。而你要知道工程之所以能找到pod里的link的库，就是因为这个xcconfig在起作用，现在被覆盖了，自然无效了。</p>

<p> 所以为了解决这个问题，你应该首先先尝试删除工程里的build setting的Other linker flags里一些可能冲突的参数设置，然后添加 $(inherited) 进去。重新执行pod update即可解决问题</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bitbucket]]></title>
    <link href="http://initlifeinc.github.io/blog/2015/08/18/bitbucket/"/>
    <updated>2015-08-18T11:07:27+08:00</updated>
    <id>http://initlifeinc.github.io/blog/2015/08/18/bitbucket</id>
    <content type="html"><![CDATA[<h1>完美的私人仓库</h1>

<p>一直想弄个私人仓库，最好无限制创建私人仓库。最好还能有个team可以共享访问私人仓库。本来差点就要去自己搭建一个gitlab了，然后突然看到bitbucket，发现原来完美的私人仓库就是他了。</p>

<p>果断申请账号（必须是免费的5人组team形势的），然后折腾一番将自己的一些小代码放上去。
中间碰到了一些问题，以为类似github上的ssh key的添加，结果添加ssh key到repo里的一个deployment key去了（这个应该是用来专门部署的时候用的key，只读性质的）。
查了下，发现overflow上有人说明了原因，果断尝试了OK解决问题，看客们自己也试试吧，值得推荐！</p>

<p><a href="http://stackoverflow.com/questions/13306435/repository-access-denied-access-via-a-deployment-key-is-read-only/13309843#13309843">http://stackoverflow.com/questions/13306435/repository-access-denied-access-via-a-deployment-key-is-read-only/13309843#13309843</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>First confusion on my side was about where exactly to set SSH Keys in BitBucket.
</span><span class='line'>
</span><span class='line'>I am new to BitBucket and I was setting a Deployment Key which gives read-access only.
</span><span class='line'>
</span><span class='line'>So make sure you are setting your rsa pub key in your BitBucket Account Settings.
</span><span class='line'>
</span><span class='line'>Click your BitBucket avatar and select Manage account. There you'll be able to set SSH Keys.
</span><span class='line'>
</span><span class='line'>I simply deleted the Deployment Key, I don't need any for now. And it worked</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[发布自己的github上的cocoaPods Pod库]]></title>
    <link href="http://initlifeinc.github.io/blog/2015/06/30/fa-bu-zi-ji-de-githubshang-de-cocoapods-podku/"/>
    <updated>2015-06-30T21:01:40+08:00</updated>
    <id>http://initlifeinc.github.io/blog/2015/06/30/fa-bu-zi-ji-de-githubshang-de-cocoapods-podku</id>
    <content type="html"><![CDATA[<p>今天第一次在github上publish一个ILEditLabel控件，同时支持了cocoapods查找该pod库。</p>

<p>这里简单说下几个小坑。</p>

<p>提交前注意给你的github的代码打tag，比如这里的0.0.1，然后编写podspec文件，对应好里面的source的tag，其实可以将pod的tag和你的库的tag一致，这样方便记忆。</p>

<p>然后你需要执行pod spec lint specFile测试下是否spec文件编写正确。</p>

<p>如果发现远程tag打错了，你可以通过命令<code>git push origin refs/tags/yourtag</code>来删除远程tag。</p>

<p>通过podspec文件的检测后，就到了发布该spec文件了。</p>

<p>那就是需要通过<code>pod trunk push specFile</code>的方式来提交spec文件到cocoapods上。</p>

<p>但是由于我是第一次提交，执行命令后提示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>You need to register a session first.</span></code></pre></td></tr></table></div></figure>


<p>所以需要参照cocoapods上的这篇文章<a href="http://guides.cocoapods.org/making/getting-setup-with-trunk.html">Getting setup with Trunk</a>先注册自己的session。</p>

<p>注册需要执行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod trunk register orta@cocoapods.org 'Orta Therox' --description='macbook air'</span></code></pre></td></tr></table></div></figure>


<p>然后你就会在你输入的orta@cocoapods.org邮箱里收到一个email，点击里面的连接完成认证，之后你就可以完成提交。至此自己故障庆祝吧~~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git及github使用，github多账号免登]]></title>
    <link href="http://initlifeinc.github.io/blog/2015/03/05/gitji-githubshi-yong-,githubduo-zhang-hao-mian-deng/"/>
    <updated>2015-03-05T12:34:00+08:00</updated>
    <id>http://initlifeinc.github.io/blog/2015/03/05/gitji-githubshi-yong-,githubduo-zhang-hao-mian-deng</id>
    <content type="html"><![CDATA[<h1>git使用及github</h1>

<p>git 和github越来越多人使用，作为一个程序员，应该懂的怎么去用，而我就是个不怎么会用的人，所以我的主管在我刚开始上班的时候就要我去熟悉git那套东西。</p>

<p>当时我依然不是很懂，但最近开始迷糊的懂了，下面是我这段时间的心得。</p>

<h2>创建ssh从而能免登访问github。</h2>

<p>命令<code>ssh-keygen</code>去创建公钥私钥，如果你只希望访问一个服务器的话，比如github，那么你就放到默认的目录下，并且使用默认的私钥和公钥文件路径，即~/.ssh/id_rsa和~/.ssh/id_rsa.pub，其中id_rsa.pub是公钥文件。我们需要将这个文件里的数据复制并粘贴到github上的ssh key里。从而通过ssh就可以面等访问github了。</p>

<p>   如果你有多个服务器需要访问，比如我们还需要访问gitlab，那么，这个时候，需要~/.ssh/config文件里的配置来区分服务器和ssh秘钥。(记得添加rsa 命令：ssh-add ~/.ssh/your_rsa)</p>

<p>   比如我自己的配置为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Host github.com
</span><span class='line'>  HostName github.com
</span><span class='line'>  User taoxiaoseng@gmail.com
</span><span class='line'>  IdentityFile /Users/Dick/.ssh/github_taoxiaoseng_rsa
</span><span class='line'>  
</span><span class='line'>Host gitlab.alibaba-inc.com
</span><span class='line'>  HostName gitlab.alibaba-inc.com
</span><span class='line'>  User guodi.ggd@taobao.com
</span><span class='line'>  IdentityFile /Users/Dick/.ssh/gitlab_rsa</span></code></pre></td></tr></table></div></figure>


<p>也就是说访问github用文件github_taoxiaoseng_rsa，访问gitlab用gitlab_rsa。注意公钥也需要上传到相应的服务器里。</p>

<!-- more -->


<p>注意实际上这里的host只是你git进行命令操作的是昵称，告诉git实际上的hsotName在哪里，用什么账号名去登陆，账号对应的证书是哪个。</p>

<p>所以在设置origin的时候，要考虑将这个替换下（如果涉及多账号的话）（多账号下不要随意乱复制github上的教程的命令，里面都是默认的命令）</p>

<p>比如我有多账号，initlifeinc和B账号，当我需要push的时候，先特别设置origin,注意我在config里配置文件是这样的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Host github.com
</span><span class='line'>        HostName github.com
</span><span class='line'>        User AAAAAAA@gmail.com
</span><span class='line'>        IdentityFile /Users/Dick/.ssh/AAAAAAA_rsa
</span><span class='line'>
</span><span class='line'>Host github.com-initlife
</span><span class='line'>        HostName github.com
</span><span class='line'>        User initlife.inc@gmail.com
</span><span class='line'>        IdentityFile /Users/Dick/.ssh/github_initlife_rsa</span></code></pre></td></tr></table></div></figure>


<p>设置origin是这样的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git remote add origin git@github.com-initlife:initlifeinc/initlifeinc.github.io.git</span></code></pre></td></tr></table></div></figure>


<p>这样当我执行<code>git push origin source</code>的时候，就会将当前分支的代码push到远程仓库里的source分支了。</p>

<p>其实还有些网上也经常说，这里不细提了。比如这些东西</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config --global user.name "you name"
</span><span class='line'>git config --global user.email youremail@gmail.com</span></code></pre></td></tr></table></div></figure>


<h2>如何创建git仓库</h2>

<p>其实每次你创建github里的仓库时，都会告诉你怎么去push，这里还是做下说明，讲我理解的说下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mkdir helloworld         
</span><span class='line'>cd helloworld
</span><span class='line'>git init          创建一个空的数据仓库
</span><span class='line'>touch readme.md
</span><span class='line'>git add .         自动判断添加相应文件到git中
</span><span class='line'>git commit -m "commit first file"         提交并且添加提交日志
</span><span class='line'>git remote add origin git@github.com:TaoXiaoSeng/test.git 这个最关键，说的是在本地git中添加remote的git地址，并且以origin命名，这样以后我们就不需要每次都写git地址了。实际上他在.git目录里的config添加了一条记录，类似这样的。注意我这里特意加了两个，地址不一样。注意github区分大小写的仓库路径（我的用户名有大小写，如果不完全匹配则认为访问不到了。）。另外注意这里的branch，当你init的时候默认创建的就是master。
</span><span class='line'>          [remote "origin"]
</span><span class='line'>              url = git@github.com:taoxiaoseng/test.git
</span><span class='line'>              fetch = +refs/heads/*:refs/remotes/origin/*
</span><span class='line'>          [remote "remote"]
</span><span class='line'>              url = git@github.com:TaoXiaoSeng/test.git
</span><span class='line'>              fetch = +refs/heads/*:refs/remotes/remote/*git 
</span><span class='line'>          [branch "master"]
</span><span class='line'>              remote = remote
</span><span class='line'>              merge = refs/heads/master
</span><span class='line'>git push -u origin master         向远程origin对应的仓库里push本地master分支。这里用-u是类似使用upstream的意思?</span></code></pre></td></tr></table></div></figure>


<h2>其他git命令</h2>

<p>git branch      罗列所有分支
git branch branchname   创建分支
git checkout branchname     切换分支
git branch -d branchname    假删除分支，如果是分支是当前正在运行的分支，则删除失败
git branch -D branchname    真删除分支</p>

<p>git ls-remote       查看远程版本库中的分支情况
git push remote :branchname     远程删除分支，注意如果分支是默认分支，则删除失败</p>

<h2>里程碑管理</h2>

<p>里程碑及tag，和分支管理类似，保存在.git/refs/tags路径下，引用可能指向一个提交，但也可能是其他类型。</p>

<ul>
<li>轻量级里程碑：用git tag <tagname> [<commit>]命令创建，引用直接指向一个提交对象<commit></li>
<li>带说明的里程碑：用git tag -a <tagname> [<commit>] 命令创建，并且在创建时需要提供创建里程碑的说明。Git会创建一个tag对象保存里程碑说明、里程碑的指向、创建里程碑的用户等信息，里程碑引用指向该Tag对象。</li>
<li>带签名的里程碑：用git tag -s <tagname> [<commit>] 命令创建。是在带说明的里程碑的基础上引入了PGP签名，保证了所创建的里程碑的完整性和不可拒绝性。</li>
</ul>

]]></content>
  </entry>
  
</feed>
